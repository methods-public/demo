# frozen_string_literal: true

#
# Cookbook Name:: letsencryptaws
# Recipe:: default
#
# Copyright 2018, Matt Kulka
#

group node['letsencryptaws']['ssl_group'] do
  action :create
end

directory node['letsencryptaws']['ssl_cert_dir'] do
  recursive true
  owner node['letsencryptaws']['ssl_owner']
  group node['letsencryptaws']['ssl_group']
  mode '755'
end

directory node['letsencryptaws']['ssl_key_dir'] do
  recursive true
  owner node['letsencryptaws']['ssl_owner']
  group node['letsencryptaws']['ssl_group']
  mode '750'
end

# Default keys
remote_file_s3 ::File.join(node['letsencryptaws']['ssl_cert_dir'], 'default.crt') do
  remote_path "/#{node['letsencryptaws']['sync_path']}/default-ssl/default.crt"
  bucket node['letsencryptaws']['sync_bucket']
  aws_access_key_id node['aws_access_key_id'] || creds('aws_access_key_id')
  aws_secret_access_key node['aws_secret_access_key'] || creds('aws_secret_access_key')
  owner node['letsencryptaws']['ssl_owner']
  group node['letsencryptaws']['ssl_group']
  mode '644'
  sensitive true
end

remote_file_s3 ::File.join(node['letsencryptaws']['ssl_cert_dir'], 'default.ca') do
  remote_path "/#{node['letsencryptaws']['sync_path']}/default-ssl/ca.crt"
  bucket node['letsencryptaws']['sync_bucket']
  aws_access_key_id node['aws_access_key_id'] || creds('aws_access_key_id')
  aws_secret_access_key node['aws_secret_access_key'] || creds('aws_secret_access_key')
  owner node['letsencryptaws']['ssl_owner']
  group node['letsencryptaws']['ssl_group']
  mode '644'
  sensitive true
end

remote_file_s3 ::File.join(node['letsencryptaws']['ssl_key_dir'], 'default.key') do
  remote_path "/#{node['letsencryptaws']['sync_path']}/default-ssl/default.key"
  bucket node['letsencryptaws']['sync_bucket']
  aws_access_key_id node['aws_access_key_id'] || creds('aws_access_key_id')
  aws_secret_access_key node['aws_secret_access_key'] || creds('aws_secret_access_key')
  owner node['letsencryptaws']['ssl_owner']
  group node['letsencryptaws']['ssl_group']
  mode '640'
  sensitive true
end

# Fake Let's Encrypt root CA for staging/test certificates
execute 'update-ca-certificates' do
  action :nothing
end

remote_file '/usr/local/share/ca-certificates/fakeroot.crt' do
  source 'https://letsencrypt.org/certs/fakelerootx1.pem'
  owner 'root'
  group 'root'
  mode '644'
  only_if { node['letsencryptaws']['test_certs'] }
  notifies :run, 'execute[update-ca-certificates]', :immediately
end

# Keys generated by certbot
node['letsencryptaws']['certs'].each_pair do |domain, _sans|
  # Real certbot-generated certificates
  remote_file_s3 ::File.join(node['letsencryptaws']['ssl_cert_dir'], "#{domain}.crt") do
    remote_path "/#{node['letsencryptaws']['sync_path']}/#{domain}/cert.pem"
    bucket node['letsencryptaws']['sync_bucket']
    aws_access_key_id node['aws_access_key_id'] || creds('aws_access_key_id')
    aws_secret_access_key node['aws_secret_access_key'] || creds('aws_secret_access_key')
    owner node['letsencryptaws']['ssl_owner']
    group node['letsencryptaws']['ssl_group']
    mode '644'
    retries 0
    ignore_failure true
    sensitive true
  end

  remote_file_s3 ::File.join(node['letsencryptaws']['ssl_cert_dir'], "#{domain}.ca") do
    remote_path "/#{node['letsencryptaws']['sync_path']}/#{domain}/chain.pem"
    bucket node['letsencryptaws']['sync_bucket']
    aws_access_key_id node['aws_access_key_id'] || creds('aws_access_key_id')
    aws_secret_access_key node['aws_secret_access_key'] || creds('aws_secret_access_key')
    owner node['letsencryptaws']['ssl_owner']
    group node['letsencryptaws']['ssl_group']
    mode '644'
    retries 0
    ignore_failure true
    sensitive true
  end

  remote_file_s3 ::File.join(node['letsencryptaws']['ssl_key_dir'], "#{domain}.key") do
    remote_path "/#{node['letsencryptaws']['sync_path']}/#{domain}/privkey.pem"
    bucket node['letsencryptaws']['sync_bucket']
    aws_access_key_id node['aws_access_key_id'] || creds('aws_access_key_id')
    aws_secret_access_key node['aws_secret_access_key'] || creds('aws_secret_access_key')
    owner node['letsencryptaws']['ssl_owner']
    group node['letsencryptaws']['ssl_group']
    mode '640'
    retries 0
    ignore_failure true
    sensitive true
  end

  # Fall back to default certificate if real certificate isn't available yet
  file ::File.join(node['letsencryptaws']['ssl_cert_dir'], "#{domain}.crt") do
    owner node['letsencryptaws']['ssl_owner']
    group node['letsencryptaws']['ssl_group']
    mode '644'
    content (lazy { IO.read(::File.join(node['letsencryptaws']['ssl_cert_dir'], 'default.crt')) })
    action :create_if_missing
  end

  file ::File.join(node['letsencryptaws']['ssl_cert_dir'], "#{domain}.ca") do
    owner node['letsencryptaws']['ssl_owner']
    group node['letsencryptaws']['ssl_group']
    mode '644'
    content (lazy { IO.read(::File.join(node['letsencryptaws']['ssl_cert_dir'], 'default.ca')) })
    action :create_if_missing
  end

  file ::File.join(node['letsencryptaws']['ssl_key_dir'], "#{domain}.key") do
    owner node['letsencryptaws']['ssl_owner']
    group node['letsencryptaws']['ssl_group']
    mode '640'
    content (lazy { IO.read(::File.join(node['letsencryptaws']['ssl_key_dir'], 'default.key')) })
    action :create_if_missing
    sensitive true
  end

  # Generate the chained certificate based on what's already there
  file ::File.join(node['letsencryptaws']['ssl_cert_dir'], "#{domain}.crt-chain") do
    owner node['letsencryptaws']['ssl_owner']
    group node['letsencryptaws']['ssl_group']
    mode '644'
    content (lazy do
      IO.read(::File.join(node['letsencryptaws']['ssl_cert_dir'], "#{domain}.crt")) + "\n" +
        IO.read(::File.join(node['letsencryptaws']['ssl_cert_dir'], "#{domain}.ca"))
    end)
  end

  # Generate a PKCS12 file backed on what's already there
  execute "generate pkcs12 store for #{domain}" do
    cwd node['letsencryptaws']['ssl_key_dir']
    only_if { node['os'] == 'linux' }
    command "openssl pkcs12 -export -in #{File.join(node['letsencryptaws']['ssl_cert_dir'], "#{domain}.crt")}" \
            "  -inkey #{domain}.key -out #{domain}.p12 -name #{domain} " \
            "  -passout \"pass:#{creds('p12_password')}\"" \
            "  -CAfile #{File.join(node['letsencryptaws']['ssl_cert_dir'], "#{domain}.ca")}" \
            "  -CApath #{node['letsencryptaws']['root_ca_dir']} -caname letsencrypt -chain"
    action :nothing
    sensitive true
    subscribes :run, "remote_file_s3[#{::File.join(node['letsencryptaws']['ssl_cert_dir'], "#{domain}.crt")}]", :delayed
  end

  log "pkcs12 store needs generated for #{domain}" do
    notifies :run, "execute[generate pkcs12 store for #{domain}]", :immediately
    not_if do
      File.exist?(::File.join(node['letsencryptaws']['ssl_key_dir'], "#{domain}.p12")) || creds('p12_password').nil?
    end
  end

  file ::File.join(node['letsencryptaws']['ssl_key_dir'], "#{domain}.p12") do
    owner node['letsencryptaws']['ssl_owner']
    group node['letsencryptaws']['ssl_group']
    mode '640'
    not_if { creds('p12_password').nil? }
  end
end

include_recipe 'letsencryptaws::import_keystore' unless node['letsencryptaws']['import_keystore'].empty? || \
                                                        node['os'] != 'linux'
